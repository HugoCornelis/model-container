/* -*- C -*- */

%union {
    char *pcIdentifier;
    double dNumber;
    int iCompOptions;
/*     int iInteger; */
    struct symtab_Attachment *patta;
    struct symtab_AxonHillock *paxhi;
    struct symtab_BioComponent *pbio;
    struct symtab_Cell *pcell;
    struct symtab_Channel *pchan;
    struct symtab_ConcentrationGateKinetic *pcgatk;
    struct symtab_HHGate *pgathh;
    struct symtab_Connection *pconn;
    struct symtab_ConnectionSymbol *pconsy;
    struct symtab_ContourPoint *pcpnt;
    struct symtab_EMContour *pemc;
    struct symtab_EquationExponential *peqe;
    struct symtab_Fiber *pfibr;
    struct symtab_Function *pfun;
    struct symtab_GateKinetic *pgatk;
    struct symtab_Group *pgrup;
    struct symtab_GroupedParameters *pgrpp;
    struct symtab_HSolveListElement *phsle;
    struct symtab_IOContainer *pioc;
    struct symtab_IdentifierIndex *pidin;
    struct symtab_InputOutput *pio;
    struct symtab_Network *pnetw;
    struct symtab_Parameters *ppar;
    struct symtab_Pool * ppool;
    struct symtab_Population *ppopu;
    struct symtab_Projection *pproj;
    struct symtab_Randomvalue *pranv;
    struct symtab_Segment *psegment;
    struct symtab_String *pstring;
    struct symtab_VConnectionSymbol *pvconsy;
    struct symtab_VContour *pvcont;
    struct symtab_VSegment *pvsegm;
}

%{
//
// Neurospaces: a library which implements a global typed symbol table to
// be used in neurobiological model maintenance and simulation.
//
// $Id: parser.rules 1.242 Sat, 10 Nov 2007 17:28:42 -0600 hugo $
//

//////////////////////////////////////////////////////////////////////////////
//'
//' Neurospaces : testbed C implementation that integrates with genesis
//'
//' Copyright (C) 1999-2008 Hugo Cornelis
//'
//' functional ideas ..	Hugo Cornelis, hugo.cornelis@gmail.com
//'
//' coding ............	Hugo Cornelis, hugo.cornelis@gmail.com
//'
//////////////////////////////////////////////////////////////////////////////

//#include "lexsupport.h"
int yylex(YYSTYPE *lvalp, void *pacParserContext);
%}

%pure_parser

%start FullModelDescription

%type <iCompOptions> SegmentInstanceOptions
%type <pcIdentifier> AttachmentIncoming
%type <pcIdentifier> AttachmentOutgoing
%type <pidin> AttachmentSectionFront
%type <phsle> AttachmentSymbol
%type <patta> AttachmentDescription
%type <patta> AttachmentSection
%type <ppar> AttachmentAttributes
%type <ppar> AttachmentData

%type <phsle> AnySymbol
%type <phsle> AxonHillockComponent
%type <paxhi> AxonHillockDescription
%type <paxhi> AxonHillockSection
%type <pidin> AxonHillockSectionFront
%type <phsle> AxonHillockSymbol
%type <phsle> CellComponent
%type <pcell> CellDescription
%type <pcell> CellSection
%type <pidin> CellSectionFront
%type <phsle> CellSymbol
%type <phsle> ChannelComponent
%type <pchan> ChannelDescription
%type <pchan> ChannelSection
%type <pidin> ChannelSectionFront
%type <phsle> ChannelSymbol
%type <pcgatk> ConcentrationGateKineticDescription
%type <pcgatk> ConcentrationGateKineticSection
%type <pidin> ConcentrationGateKineticSectionFront
%type <phsle> ConcentrationGateKineticSymbol
%type <pconsy> ConnectionDescription
%type <pconsy> ConnectionSection
%type <pidin> ConnectionSectionFront
%type <phsle> ConnectionSymbol
%type <pcpnt> ContourPointDescription
%type <pcpnt> ContourPointSection
%type <pidin> ContourPointSectionFront
%type <phsle> ContourPointSymbol
%type <phsle> EMContourComponent
%type <pemc> EMContourDescription
%type <pemc> EMContourSection
%type <pidin> EMContourSectionFront
%type <phsle> EMContourSymbol
%type <peqe> EquationExponentialDescription
%type <peqe> EquationExponentialSection
%type <pidin> EquationExponentialSectionFront
%type <phsle> EquationExponentialSymbol
%type <pfibr> FiberDescription
%type <pfibr> FiberSection
%type <pidin> FiberSectionFront
%type <phsle> FiberSymbol
%type <phsle> GateKineticBackwardComponent
%type <pgatk> GateKineticBackwardDescription
%type <pgatk> GateKineticBackwardSection
%type <pidin> GateKineticBackwardSectionFront
%type <phsle> GateKineticBackwardSymbol
%type <phsle> GateKineticForwardComponent
%type <pgatk> GateKineticForwardDescription
%type <pgatk> GateKineticForwardSection
%type <pidin> GateKineticForwardSectionFront
%type <phsle> GateKineticForwardSymbol
%type <phsle> GateKineticPartComponent
%type <pgatk> GateKineticPartDescription
%type <pgatk> GateKineticPartSection
%type <pidin> GateKineticPartSectionFront
%type <phsle> GateKineticPartSymbol
%type <pgrup> GroupDescription
%type <pgrup> GroupSection
%type <pidin> GroupSectionFront
%type <phsle> GroupSymbol
%type <pgrpp> GroupedParametersDescription
%type <pgrpp> GroupedParametersSection
%type <pidin> GroupedParametersSectionFront
%type <phsle> GroupedParametersSymbol
%type <phsle> HHGateComponent
%type <pgathh> HHGateDescription
%type <pgathh> HHGateSection
%type <pidin> HHGateSectionFront
%type <phsle> HHGateSymbol
%type <phsle> NetworkComponent
%type <pnetw> NetworkDescription
%type <pnetw> NetworkSection
%type <pidin> NetworkSectionFront
%type <phsle> NetworkSymbol
%type <ppool> PoolDescription
%type <ppool> PoolSection
%type <pidin> PoolSectionFront
%type <phsle> PoolSymbol
%type <phsle> PopulationComponent
%type <ppopu> PopulationDescription
%type <ppopu> PopulationSection
%type <pidin> PopulationSectionFront
%type <phsle> PopulationSymbol
%type <phsle> ProjectionComponent
%type <pproj> ProjectionDescription
%type <pproj> ProjectionSection
%type <pidin> ProjectionSectionFront
%type <phsle> ProjectionSymbol
%type <phsle> RandomvalueComponent
%type <pranv> RandomvalueDescription
%type <pranv> RandomvalueSection
%type <pidin> RandomvalueSectionFront
%type <phsle> RandomvalueSymbol
%type <phsle> SegmentComponent
%type <psegment> SegmentDescription
%type <psegment> SegmentSection
%type <pidin> SegmentSectionFront
%type <phsle> SegmentSymbol
%type <phsle> VConnectionSymbolComponent
%type <pvconsy> VConnectionSymbolDescription
%type <pvconsy> VConnectionSymbolSection
%type <pidin> VConnectionSymbolSectionFront
%type <phsle> VConnectionSymbolSymbol
%type <phsle> VContourComponent
%type <pvcont> VContourDescription
%type <pvcont> VContourSection
%type <pidin> VContourSectionFront
%type <phsle> VContourSymbol
%type <phsle> VSegmentComponent
%type <pvsegm> VSegmentDescription
%type <pvsegm> VSegmentSection
%type <pidin> VSegmentSectionFront
%type <phsle> VSegmentSymbol

%type <phsle> ChildSectionFront
%type <phsle> ChildSectionOptionalInputOptionalParameters
%type <phsle> OptionalChildSectionOptionalInputOptionalParameters
%type <pio> FixedItemInputRelations
%type <pio> OptionalItemInputRelations
%type <pio> ItemInputRelations
%type <ppar> OptionalItemParameters
%type <ppar> ItemParameters
%type <ppar> Attributes
%type <ppar> Parameters
%type <ppar> ParametersEnumerated
%type <ppar> Parameter
%type <pfun> FunctionSpecification
%type <pcIdentifier> FunctionIdentifier
%type <ppar> FunctionParameters
/* %type <ppar> FunctionParameter */
/* %type <pcIdentifier> FunctionParameterName */
/* %type <pioc> OptionalInputOutputRelations */
%type <pioc> InputOutputRelations
%type <pio> InputRelations
%type <pio> OutputRelations
%type <pidin> FieldOrIOOptionalHierarchical
%type <pidin> FieldOrIOHierarchical
%type <pidin> FieldOrIO
%type <pidin> Field
%type <pidin> IO
%type <pidin> IdentifierOptionIndex
%type <pidin> IdentifierOptionIndexPushedPidin
%type <pidin> IdentifierHierarchicalNameSpaceRooted
%type <pidin> IdentifierHierarchicalRooted
%type <pidin> IdentifierHierarchicalOptionalRooted
%type <pidin> IdentifierHierarchical
%type <pcIdentifier> Identifier


%%


/*
**
** keyword conventions in regex syntax
**
**
** FullModelDescription : grammatical start symbol (root of derivation tree)
**
** .*Contents : grammatical entity that is reduced to a file contents
**		Every file level used to have its own symbol, actually obsoleted now.
**
** .*Component : grammatical entity that is reduced from .*Symbol and has
**			an associated struct symtab_HSolveListElement * 
**			semantic value.
**			It defines the .*Symbols allowed for the given 
**			component and thus defines the 'physiological'
**			hierarchy.
**
**	e.g. :	equation -> channel -> segment -> cell -> network
**		connection -> network
**
**		segment -> cell -> population -> network
**		connection -> projection -> network
**
** .*Symbol : grammatical entity that is reduced from .*Section and has
**		an associated struct symtab_HSolveListElement * 
**		semantic value.
**
** .*Section : grammatical entity surrounded with delimiting keywords
**		The beginning delimiting keyword is coded within a front 
**		section that normally also registers the current working 
**		element.
**		The ending delimiting keyword is coded within a ending section.
**		This section normally unregisters the working element.
**
**	e.g.	PoolSection : PoolSectionFront More_keywords PoolSectionEnd ;
**		PoolSectionEnd : END POOL ;
**		PoolSectionFront : POOL Identifier ;
**
**
** .*Description : grammatical entity inside a section, giving attributes for
**			one instance
**
**	e.g.	PoolSection : PoolSectionFront More_keywords PoolSectionEnd ;
**		PoolSectionFront : POOL Identifier ;
**		PoolSectionEnd : END POOL ;
**		PoolDescription : Keywords_giving_attributes_for_any_pool
**
**
*/

FullModelDescription
	:
		FullModelHeader
		FullModelContents
		FullModelTail
	;

FullModelHeader
	:
		/* ok if no interpreter sequence	*/
	|
		TOKEN_SHEBANGER
		{
#line
		    ParserStart();
		}
	;

FullModelContents		/* no type	*/
	:
		ParseStateHeader

		FullModelHeaderSection

		ParseStateDependencies

		DependenciesSection

		ParseStatePrivateModels

		PrivateModelsSection

		ParseStatePublicModels

		PublicModelsSection

		ParseStateDone
	;

FullModelTail
	:
		{
#line
		    ParserFinish();
		}
	;

/*
** tokens to register parser states (to avoid shift/reduce conflicts)
*/

ParseStateHeader
	:
		{
#line
		    //- register parsing-header state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_HEADER);
		}
	;

ParseStateDependencies
	:
		{
#line
		    //- register parsing-dependencies state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_DEPENDENCIES);
		}
	;

ParseStatePrivateModels
	:
		{
#line
		    //- register parsing-private-models state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_PRIVATEMODELS);
		}
	;

ParseStatePublicModels
	:
		{
#line
		    //- register parsing-public-models state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_PUBLICMODELS);
		}
	;

ParseStateDone
	:
		{
#line
		    //- unregister parsing state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | 0);
		}
	;

FullModelHeaderSection
	:
		TOKEN_NEUROSPACES
		ModelLevelIdentification
		{
#line
		    //t register/check type of file
		}
	;

ModelLevelIdentification
	:
		TOKEN_NDF
	;

DependenciesSection
	:
	|
		DependenciesSectionFront
			DependenciesEnumerated
		DependenciesSectionEnd
		{
#line
		}
	;

DependenciesSectionFront
	:
		TOKEN_IMPORT
	;

DependenciesSectionEnd
	:
		TOKEN_END TOKEN_IMPORT
		{
#line
		    //- give diagnostics : activation of dependencies

		    ParserMessage
			((PARSERCONTEXT *)pacParserContext,
			 LEVEL_GLOBALMSG_SYMBOLREPORT,
			 "DependenciesSectionEnd",
			 "Activating %s's dependencies"
			 "(dependency list not yet)",
			 ParserContextGetFilename
			 ((PARSERCONTEXT *)pacParserContext));
		}
	;


DependenciesEnumerated
	:
		{
#line
		    //! give msg : starting import of dependencies ?
		}
	|
		DependenciesEnumerated
		TOKEN_FILE
		Identifier
		TOKEN_STRING
		FileOptions
		{
#line
		    int bFail;
		    char *pc = NULL;

		    //- remove ending '"'

		    $4->pcString[$4->iLength - 1] = '\0';
		    pc = &$4->pcString[1];

		    //- qualify file name

		    pc
			= ParserContextQualifyFilename
			  ((PARSERCONTEXT *)pacParserContext, pc);

		    if (pc)
		    {
			//- if importing files is not disabled by the options

			if (!(((PARSERCONTEXT *)pacParserContext)
			      ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_IMPORTING))
			{
			    //- parse cell file

			    //t pass description file specific options as parameter

			    bFail
				= ParserImport
				  ((PARSERCONTEXT *)pacParserContext,
				   pc,
				   $3);
			}
		    }
		    else
		    {
			NeurospacesError
			    ((PARSERCONTEXT *)pacParserContext,
			     "DependenciesEnumerated",
			     "Could not qualify '%s' (file not found ?)\n",
			     &$4->pcString[1]);
		    }

		    //! memory leak : $4
		}
	;

FileOptions
	:
		{
#line
		    //t pass options to stack
		}
	;

PrivateModelsSection
	:
	|
		PrivateModelsSectionFront
			PrivateModelsEnumerated
		PrivateModelsSectionEnd
		{
#line
		    //- give diagnostics : activation of private models

		    ParserMessage
			((PARSERCONTEXT *)pacParserContext,
			 LEVEL_GLOBALMSG_SYMBOLREPORT,
			 "PrivateModelsSection",
			 "Activating %s's private models"
			 "(private models list not yet)",
			 ParserContextGetFilename
			 ((PARSERCONTEXT *)pacParserContext));
		}
	;

PrivateModelsSectionFront
	:
		TOKEN_PRIVATE_MODELS
		{
#line
		}
	;

PrivateModelsSectionEnd
	:
		TOKEN_END TOKEN_PRIVATE_MODELS
		{
#line
		    //- give diagnostics : activation of private models

		    ParserMessage
			((PARSERCONTEXT *)pacParserContext,
			 LEVEL_GLOBALMSG_SYMBOLREPORT,
			 "PrivateModelsSectionEnd",
			 "Activating %s's private models"
			 "(private models list not yet)",
			 ParserContextGetFilename
			 ((PARSERCONTEXT *)pacParserContext));
		}
	;

/*
** enumeration of private models
**
*/

PrivateModelsEnumerated
	:
		{
#line
		}
	|
		PrivateModelsEnumerated

		/* export regular private model	 		*/

		AnySymbol
		{
#line
		    //- if private model description available

		    if ($2)
		    {
			//- add private model

			ParserAddPrivateModel
			    ((PARSERCONTEXT *)pacParserContext, $2);
		    }

		    //- else

		    else
		    {
			//- give diagnostics : empty private model

			//t warning instead of error

			NeurospacesError
			    ((PARSERCONTEXT *)pacParserContext,
			     "PrivateModelsEnumerated",
			     "Empty private model");
		    }
		}
	|
		PrivateModelsEnumerated

		/* export private model from dependencies	*/

		TOKEN_ALIAS
			IdentifierHierarchicalNameSpaceRooted
			Identifier
			OptionalItemParameters
			OptionalChildSectionOptionalInputOptionalParameters
		TOKEN_END TOKEN_ALIAS
		{
#line
		    //v alias target

		    struct symtab_HSolveListElement *phsleProto = NULL;

		    //- if model dependency lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_DEPCY_LOOKUP))
		    {
			//- lookup refereed model in dependencies

			phsleProto
			    = ParserLookupDependencyModel
			      ((PARSERCONTEXT *)pacParserContext, $3);

			//- if symbol found

			if (phsleProto)
			{
			    struct symtab_HSolveListElement *phsle
				= SymbolCreateAlias(phsleProto, IdinNewFromChars($4));

			    //- set parameters

			    SymbolAssignParameters(phsle, $5);

			    //- link children

			    if ($6)
			    {
				SymbolAddChild(phsle, $6);

				//- reset actual symbol

				ParserContextSetActual
				    ((PARSERCONTEXT *)pacParserContext, phsle);
			    }

			    //- add private model

			    ParserAddPrivateModel
				((PARSERCONTEXT *)pacParserContext, phsle);
			}

			//- else

			else
			{
			    //- give error msg

			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "PrivateModelsEnumerated",
				 "Dependency Symbol(%s::%s) not found.",
				 $3->pcIdentifier
				 ? $3->pcIdentifier
				 : "NULL",
				 $3->pidinNext
				 && $3->pidinNext->pcIdentifier
				 ? $3->pidinNext->pcIdentifier
				 : "NULL");
			}
		    }
		}
	|
		PrivateModelsEnumerated

		/* export private model from dependencies	*/

		TOKEN_ALIAS
			Identifier
			Identifier
			OptionalItemParameters
			OptionalChildSectionOptionalInputOptionalParameters
		TOKEN_END TOKEN_ALIAS
		{
#line
		    //v alias target

		    struct symtab_HSolveListElement *phsleProto = NULL;

		    //- if model dependency lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_DEPCY_LOOKUP))
		    {
			//- lookup private model, set as alias target

			phsleProto
			    = ParserLookupPrivateModel
			      (/*(PARSERCONTEXT *)pacParserContext,*/$3);

			//- if symbol found

			if (phsleProto)
			{
			    struct symtab_HSolveListElement *phsle
				= SymbolCreateAlias(phsleProto, IdinNewFromChars($4));

			    //- set parameters

			    SymbolAssignParameters(phsle, $5);

			    //- link children

			    if ($6)
			    {
				SymbolAddChild(phsle, $6);

				//- reset actual symbol

				ParserContextSetActual
				    ((PARSERCONTEXT *)pacParserContext, phsle);
			    }

			    //- add private model

			    ParserAddPrivateModel
				((PARSERCONTEXT *)pacParserContext, phsle);
			}

			//- else

			else
			{
			    //- give error msg

			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "PrivateModelsEnumerated",
				 "PrivateModel Symbol(%s) not found.",
				 $3 ? $3 : "NULL");
			}
		    }
		}
	;

PublicModelsSection
	:
	|
		PublicModelsSectionFront
			PublicModelsEnumerated
		PublicModelsSectionEnd
		{
#line
		}
	;

PublicModelsSectionFront
	:
		TOKEN_PUBLIC_MODELS
		{
#line
		    //- clear current element stack

		    ParserCurrentElementPopAll
			((PARSERCONTEXT *)pacParserContext);
		}
	;

PublicModelsSectionEnd
	:
		TOKEN_END TOKEN_PUBLIC_MODELS
		{
#line
		    //! makes private models invisible
		}
	;

PublicModelsEnumerated
	:
	|
		PublicModelsEnumerated
		TOKEN_ORIGIN TOKEN_NUMBER ',' TOKEN_NUMBER ',' TOKEN_NUMBER
	|
		PublicModelsEnumerated
		TOKEN_RELATIVE
/* 	| */
/* 		PublicModelsEnumerated */
/* 		TOKEN_ALGORITHM */
/* 		Identifier */
/* 		TOKEN_ALGORITHMPARAMETERS */
/* 		{ */
/* #line */
/* 		    //- import & init algorithm */

/* 		    //! because TOKEN_ALGORITHMPARAMETERS returns a string, */
/* 		    //! we loose some bytes here */
/* 		    //! perhaps they are on the stack, still needs a check */

/* 		    ParserAlgorithmImport */
/* 			((PARSERCONTEXT *)pacParserContext, */
/* 			 $3, */
/* 			 $4->pcString); */

/* 		    //t algorithm must be event based */
/* 		    //t register interested events from algorithm */
/* 		    //t install algorithm callback */
/* 		} */
/* 		TOKEN_END TOKEN_ALGORITHMPARAMETERS */
	|
		PublicModelsEnumerated
		AnySymbol
		{
#line
		    //- add symbol to models

		    ParserAddPublicModel
			((PARSERCONTEXT *)pacParserContext,
			 $2);
		}
	|
		PublicModelsEnumerated

		/* export model from private models	*/

		TOKEN_ALIAS
			Identifier
			Identifier
			OptionalItemParameters
			OptionalChildSectionOptionalInputOptionalParameters
		TOKEN_END TOKEN_ALIAS
		{
#line
		    //v alias target

		    struct symtab_HSolveListElement *phsleProto = NULL;

		    //- if private model lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_PRIVATE_LOOKUP))
		    {
			//- lookup private model, set as alias target

			phsleProto
			    = ParserLookupPrivateModel
			      (/*(PARSERCONTEXT *)pacParserContext,*/$3);

			//- if symbol found

			if (phsleProto)
			{
			    struct symtab_HSolveListElement *phsle
				= SymbolCreateAlias(phsleProto, IdinNewFromChars($4));

			    //- set parameters

			    SymbolAssignParameters(phsle, $5);

			    //- link children

			    if ($6)
			    {
				SymbolAddChild(phsle, $6);

				//- reset actual symbol

				ParserContextSetActual
				    ((PARSERCONTEXT *)pacParserContext, phsle);
			    }

			    //- add model

			    ParserAddPublicModel
				((PARSERCONTEXT *)pacParserContext, phsle);
			}

			//- else

			else
			{
			    //- give error msg

			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "PublicModelsEnumerated",
				 "PrivateModel Symbol(%s) not found.",
				 $3 ? $3 : "NULL");
			}
		    }
		}
	;

