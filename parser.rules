/* -*- C -*- */

%union {
    char *pcIdentifier;
    double dNumber;
    int iCompOptions;
/*     int iInteger; */
    struct symtab_Attachment *patta;
    struct symtab_AxonHillock *paxhi;
    struct symtab_BioComponent *pbio;
    struct symtab_Cell *pcell;
    struct symtab_Channel *pchan;
    struct symtab_ConcentrationGateKinetic *pcgatk;
    struct symtab_HHGate *pgathh;
    struct symtab_Connection *pconn;
    struct symtab_ConnectionSymbol *pconsy;
    struct symtab_ContourPoint *pcpnt;
    struct symtab_EMContour *pemc;
    struct symtab_EquationExponential *peqe;
    struct symtab_Fiber *pfibr;
    struct symtab_Function *pfun;
    struct symtab_GateKinetic *pgatk;
    struct symtab_Group *pgrup;
    struct symtab_GroupedParameters *pgrpp;
    struct symtab_HSolveListElement *phsle;
    struct symtab_IOContainer *pioc;
    struct symtab_IdentifierIndex *pidin;
    struct symtab_InputOutput *pio;
    struct symtab_Network *pnetw;
    struct symtab_Parameters *ppar;
    struct symtab_Pool * ppool;
    struct symtab_Population *ppopu;
    struct symtab_Projection *pproj;
    struct symtab_Randomvalue *pranv;
    struct symtab_Segment *psegment;
    struct symtab_String *pstring;
    struct symtab_VConnectionSymbol *pvconsy;
    struct symtab_VContour *pvcont;
    struct symtab_VSegment *pvsegm;
}

%{
//
// Neurospaces: a library which implements a global typed symbol table to
// be used in neurobiological model maintenance and simulation.
//
// $Id: parser.rules 1.242 Sat, 10 Nov 2007 17:28:42 -0600 hugo $
//

//////////////////////////////////////////////////////////////////////////////
//'
//' Neurospaces : testbed C implementation that integrates with genesis
//'
//' Copyright (C) 1999-2008 Hugo Cornelis
//'
//' functional ideas ..	Hugo Cornelis, hugo.cornelis@gmail.com
//'
//' coding ............	Hugo Cornelis, hugo.cornelis@gmail.com
//'
//////////////////////////////////////////////////////////////////////////////

//#include "lexsupport.h"
int yylex(YYSTYPE *lvalp, void *pacParserContext);
%}

%pure_parser

%start FullModelDescription

%type <phsle> EMContourSymbol
%type <pemc> EMContourSection
%type <pidin> EMContourSectionFront
%type <pemc> EMContourDescription
%type <phsle> EMContourComponent

%type <phsle> VContourSymbol
%type <pvcont> VContourSection
%type <pidin> VContourSectionFront
%type <pvcont> VContourDescription
%type <phsle> VContourComponent

%type <phsle> ContourPointSymbol
%type <pcpnt> ContourPointSection
%type <pidin> ContourPointSectionFront
%type <pcpnt> ContourPointDescription

%type <pgatk> GateKineticPartDescription
%type <phsle> GateKineticPartComponent

%type <phsle> GateKineticBackwardComponent
%type <phsle> GateKineticForwardComponent
%type <pidin> GateKineticPartSectionFront

%type <pcgatk> ConcentrationGateKineticDescription
%type <pidin> ConcentrationGateKineticSectionFront
%type <pcgatk> ConcentrationGateKineticSection

%type <phsle> HHGateSymbol
%type <pgathh> HHGateSection
%type <pidin> HHGateSectionFront
%type <pgathh> HHGateDescription
%type <phsle> HHGateComponent
%type <phsle> ConcentrationGateKineticSymbol
%type <phsle> GateKineticBackwardSymbol
%type <phsle> GateKineticForwardSymbol
%type <phsle> GateKineticPartSymbol
%type <pgatk> GateKineticBackwardSection
%type <pidin> GateKineticBackwardSectionFront
%type <pgatk> GateKineticForwardSection
%type <pidin> GateKineticForwardSectionFront
%type <pgatk> GateKineticPartSection
%type <pgatk> GateKineticBackwardDescription
%type <pgatk> GateKineticForwardDescription

%type <phsle> AxonHillockComponent
%type <phsle> FiberSymbol
%type <pfibr> FiberSection
%type <pidin> FiberSectionFront
%type <pfibr> FiberDescription
%type <phsle> GroupSymbol
%type <pgrup> GroupSection
%type <pidin> GroupSectionFront
%type <pgrup> GroupDescription
%type <phsle> GroupedParametersSymbol
%type <pgrpp> GroupedParametersSection
%type <pidin> GroupedParametersSectionFront
%type <pgrpp> GroupedParametersDescription
%type <phsle> ChannelComponent
%type <phsle> SegmentComponent
%type <phsle> VSegmentComponent
%type <phsle> CellComponent
%type <phsle> RandomvalueComponent
%type <phsle> PopulationComponent
%type <phsle> VConnectionSymbolComponent
%type <phsle> NetworkComponent
%type <phsle> ProjectionComponent
%type <phsle> AnySymbol
%type <phsle> AttachmentSymbol
%type <phsle> EquationExponentialSymbol
%type <phsle> PoolSymbol
%type <phsle> AxonHillockSymbol
%type <phsle> ChannelSymbol
%type <phsle> SegmentSymbol
%type <phsle> VSegmentSymbol
%type <phsle> CellSymbol
%type <phsle> RandomvalueSymbol
%type <phsle> PopulationSymbol
%type <phsle> ProjectionSymbol
%type <phsle> NetworkSymbol
%type <phsle> VConnectionSymbolSymbol
%type <phsle> ConnectionSymbol
%type <patta> AttachmentSection
%type <pidin> AttachmentSectionFront
%type <patta> AttachmentDescription
%type <ppar> AttachmentData
%type <ppar> AttachmentAttributes
%type <pcIdentifier> AttachmentIncoming
%type <pcIdentifier> AttachmentOutgoing
%type <ppool> PoolSection
%type <pidin> PoolSectionFront
%type <ppool> PoolDescription
%type <pchan> ChannelSection
%type <pidin> ChannelSectionFront
%type <pchan> ChannelDescription
%type <paxhi> AxonHillockSection
%type <pidin> AxonHillockSectionFront
%type <paxhi> AxonHillockDescription
%type <peqe> EquationExponentialSection
%type <pidin> EquationExponentialSectionFront
%type <peqe> EquationExponentialDescription
%type <psegment> SegmentSection
%type <pidin> SegmentSectionFront
%type <psegment> SegmentDescription
%type <pvsegm> VSegmentSection
%type <pvsegm> VSegmentDescription
%type <pidin> VSegmentSectionFront
%type <iCompOptions> SegmentInstanceOptions
%type <pcell> CellSection
%type <pidin> CellSectionFront
%type <pcell> CellDescription
%type <pranv> RandomvalueSection
%type <pidin> RandomvalueSectionFront
%type <pranv> RandomvalueDescription
%type <ppopu> PopulationSection
%type <pidin> PopulationSectionFront
%type <ppopu> PopulationDescription
%type <pconsy> ConnectionSection
%type <pconsy> ConnectionDescription
%type <pidin> ConnectionSectionFront
%type <pvconsy> VConnectionSymbolSection
%type <pidin> VConnectionSymbolSectionFront
%type <pvconsy> VConnectionSymbolDescription
%type <pproj> ProjectionSection
%type <pidin> ProjectionSectionFront
%type <pproj> ProjectionDescription
%type <pnetw> NetworkSection
%type <pidin> NetworkSectionFront
%type <pnetw> NetworkDescription
%type <phsle> ChildSectionFront
%type <phsle> ChildSectionOptionalInputOptionalParameters
%type <phsle> OptionalChildSectionOptionalInputOptionalParameters
%type <pio> FixedItemInputRelations
%type <pio> OptionalItemInputRelations
%type <pio> ItemInputRelations
%type <ppar> OptionalItemParameters
%type <ppar> ItemParameters
%type <ppar> Attributes
%type <ppar> Parameters
%type <ppar> ParametersEnumerated
%type <ppar> Parameter
%type <pfun> FunctionSpecification
%type <pcIdentifier> FunctionIdentifier
%type <ppar> FunctionParameters
/* %type <ppar> FunctionParameter */
/* %type <pcIdentifier> FunctionParameterName */
/* %type <pioc> OptionalInputOutputRelations */
%type <pioc> InputOutputRelations
%type <pio> InputRelations
%type <pio> OutputRelations
%type <pidin> FieldOrIOOptionalHierarchical
%type <pidin> FieldOrIOHierarchical
%type <pidin> FieldOrIO
%type <pidin> Field
%type <pidin> IO
%type <pidin> IdentifierOptionIndex
/* %type <pidin> OptionalIdentifierOptionIndexPushedPidin */
/* %type <pidin> OptionalIdentifierOptionIndex */
%type <pidin> IdentifierOptionIndexPushedPidin
%type <pidin> IdentifierHierarchicalNameSpaceRooted
%type <pidin> IdentifierHierarchicalRooted
%type <pidin> IdentifierHierarchicalOptionalRooted
%type <pidin> IdentifierHierarchical
/* %type <pcIdentifier> OptionalIdentifier */
%type <pcIdentifier> Identifier
/* %type <iInteger> Integer */


%%


/*
**
** keyword conventions in regex syntax
**
**
** FullModelDescription : grammatical start symbol (root of derivation tree)
**
** .*Contents : grammatical entity that is reduced to a file contents
**		Every file level used to have its own symbol, actually obsoleted now.
**
** .*Component : grammatical entity that is reduced from .*Symbol and has
**			an associated struct symtab_HSolveListElement * 
**			semantic value.
**			It defines the .*Symbols allowed for the given 
**			component and thus defines the 'physiological'
**			hierarchy.
**
**	e.g. :	equation -> channel -> segment -> cell -> network
**		connection -> network
**
**		segment -> cell -> population -> network
**		connection -> projection -> network
**
** .*Symbol : grammatical entity that is reduced from .*Section and has
**		an associated struct symtab_HSolveListElement * 
**		semantic value.
**
** .*Section : grammatical entity surrounded with delimiting keywords
**		The beginning delimiting keyword is coded within a front 
**		section that normally also registers the current working 
**		element.
**		The ending delimiting keyword is coded within a ending section.
**		This section normally unregisters the working element.
**
**	e.g.	PoolSection : PoolSectionFront More_keywords PoolSectionEnd ;
**		PoolSectionEnd : END POOL ;
**		PoolSectionFront : POOL Identifier ;
**
**
** .*Description : grammatical entity inside a section, giving attributes for
**			one instance
**
**	e.g.	PoolSection : PoolSectionFront More_keywords PoolSectionEnd ;
**		PoolSectionFront : POOL Identifier ;
**		PoolSectionEnd : END POOL ;
**		PoolDescription : Keywords_giving_attributes_for_any_pool
**
**
*/

FullModelDescription
	:
		FullModelHeader
		FullModelContents
		FullModelTail
	;

FullModelHeader
	:
		/* ok if no interpreter sequence	*/
	|
		TOKEN_SHEBANGER
		{
#line
		    ParserStart();
		}
	;

FullModelContents		/* no type	*/
	:
		ParseStateHeader

		FullModelHeaderSection

		ParseStateDependencies

		DependenciesSection

		ParseStatePrivateModels

		PrivateModelsSection

		ParseStatePublicModels

		PublicModelsSection

		ParseStateDone
	;

FullModelTail
	:
		{
#line
		    ParserFinish();
		}
	;

/*
** tokens to register parser states (to avoid shift/reduce conflicts)
*/

ParseStateHeader
	:
		{
#line
		    //- register parsing-header state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_HEADER);
		}
	;

ParseStateDependencies
	:
		{
#line
		    //- register parsing-dependencies state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_DEPENDENCIES);
		}
	;

ParseStatePrivateModels
	:
		{
#line
		    //- register parsing-private-models state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_PRIVATEMODELS);
		}
	;

ParseStatePublicModels
	:
		{
#line
		    //- register parsing-public-models state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | PARSER_STATE_PUBLICMODELS);
		}
	;

ParseStateDone
	:
		{
#line
		    //- unregister parsing state

		    ((PARSERCONTEXT *)pacParserContext)->iState
			= ((((PARSERCONTEXT *)pacParserContext)->iState
			     & ~PARSER_MASK_STATES)
			    | 0);
		}
	;

FullModelHeaderSection
	:
		TOKEN_NEUROSPACES
		ModelLevelIdentification
		{
#line
		    //t register/check type of file
		}
	;

ModelLevelIdentification
	:
		TOKEN_NDF
	;

DependenciesSection
	:
	|
		DependenciesSectionFront
			DependenciesEnumerated
		DependenciesSectionEnd
		{
#line
		}
	;

DependenciesSectionFront
	:
		TOKEN_IMPORT
	;

DependenciesSectionEnd
	:
		TOKEN_END TOKEN_IMPORT
		{
#line
		    //- give diagnostics : activation of dependencies

		    ParserMessage
			((PARSERCONTEXT *)pacParserContext,
			 LEVEL_GLOBALMSG_SYMBOLREPORT,
			 "DependenciesSectionEnd",
			 "Activating %s's dependencies"
			 "(dependency list not yet)",
			 ParserContextGetFilename
			 ((PARSERCONTEXT *)pacParserContext));
		}
	;


DependenciesEnumerated
	:
		{
#line
		    //! give msg : starting import of dependencies ?
		}
	|
		DependenciesEnumerated
		TOKEN_FILE
		Identifier
		TOKEN_STRING
		FileOptions
		{
#line
		    int bFail;
		    char *pc = NULL;

		    //- remove ending '"'

		    $4->pcString[$4->iLength - 1] = '\0';
		    pc = &$4->pcString[1];

		    //- qualify file name

		    pc
			= ParserContextQualifyFilename
			  ((PARSERCONTEXT *)pacParserContext, pc);

		    if (pc)
		    {
			//- if importing files is not disabled by the options

			if (!(((PARSERCONTEXT *)pacParserContext)
			      ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_IMPORTING))
			{
			    //- parse cell file

			    //t pass description file specific options as parameter

			    bFail
				= ParserImport
				  ((PARSERCONTEXT *)pacParserContext,
				   pc,
				   $3);
			}
		    }
		    else
		    {
			NeurospacesError
			    ((PARSERCONTEXT *)pacParserContext,
			     "DependenciesEnumerated",
			     "Could not qualify '%s' (file not found ?)\n",
			     &$4->pcString[1]);
		    }

		    //! memory leak : $4
		}
	;

FileOptions
	:
		{
#line
		    //t pass options to stack
		}
	;

PrivateModelsSection
	:
	|
		PrivateModelsSectionFront
			PrivateModelsEnumerated
		PrivateModelsSectionEnd
		{
#line
		    //- give diagnostics : activation of private models

		    ParserMessage
			((PARSERCONTEXT *)pacParserContext,
			 LEVEL_GLOBALMSG_SYMBOLREPORT,
			 "PrivateModelsSection",
			 "Activating %s's private models"
			 "(private models list not yet)",
			 ParserContextGetFilename
			 ((PARSERCONTEXT *)pacParserContext));
		}
	;

PrivateModelsSectionFront
	:
		TOKEN_PRIVATE_MODELS
		{
#line
		}
	;

PrivateModelsSectionEnd
	:
		TOKEN_END TOKEN_PRIVATE_MODELS
		{
#line
		    //- give diagnostics : activation of private models

		    ParserMessage
			((PARSERCONTEXT *)pacParserContext,
			 LEVEL_GLOBALMSG_SYMBOLREPORT,
			 "PrivateModelsSectionEnd",
			 "Activating %s's private models"
			 "(private models list not yet)",
			 ParserContextGetFilename
			 ((PARSERCONTEXT *)pacParserContext));
		}
	;

/*
** enumeration of private models
**
*/

PrivateModelsEnumerated
	:
		{
#line
		}
	|
		PrivateModelsEnumerated

		/* export regular private model	 		*/

		AnySymbol
		{
#line
		    //- if private model description available

		    if ($2)
		    {
			//- add private model

			ParserAddPrivateModel
			    ((PARSERCONTEXT *)pacParserContext, $2);
		    }

		    //- else

		    else
		    {
			//- give diagnostics : empty private model

			//t warning instead of error

			NeurospacesError
			    ((PARSERCONTEXT *)pacParserContext,
			     "PrivateModelsEnumerated",
			     "Empty private model");
		    }
		}
	|
		PrivateModelsEnumerated

		/* export private model from dependencies	*/

		TOKEN_ALIAS
			IdentifierHierarchicalNameSpaceRooted
			Identifier
			OptionalItemParameters
			OptionalChildSectionOptionalInputOptionalParameters
		TOKEN_END TOKEN_ALIAS
		{
#line
		    //v alias target

		    struct symtab_HSolveListElement *phsleProto = NULL;

		    //- if model dependency lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_DEPCY_LOOKUP))
		    {
			//- lookup refereed model in dependencies

			phsleProto
			    = ParserLookupDependencyModel
			      ((PARSERCONTEXT *)pacParserContext, $3);

			//- if symbol found

			if (phsleProto)
			{
			    struct symtab_HSolveListElement *phsle
				= SymbolCreateAlias(phsleProto, IdinNewFromChars($4));

			    //- set parameters

			    SymbolAssignParameters(phsle, $5);

			    //- link children

			    if ($6)
			    {
				SymbolAddChild(phsle, $6);

				//- reset actual symbol

				ParserContextSetActual
				    ((PARSERCONTEXT *)pacParserContext, phsle);
			    }

			    //- add private model

			    ParserAddPrivateModel
				((PARSERCONTEXT *)pacParserContext, phsle);
			}

			//- else

			else
			{
			    //- give error msg

			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "PrivateModelsEnumerated",
				 "Dependency Symbol(%s::%s) not found.",
				 $3->pcIdentifier
				 ? $3->pcIdentifier
				 : "NULL",
				 $3->pidinNext
				 && $3->pidinNext->pcIdentifier
				 ? $3->pidinNext->pcIdentifier
				 : "NULL");
			}
		    }
		}
	|
		PrivateModelsEnumerated

		/* export private model from dependencies	*/

		TOKEN_ALIAS
			Identifier
			Identifier
			OptionalItemParameters
			OptionalChildSectionOptionalInputOptionalParameters
		TOKEN_END TOKEN_ALIAS
		{
#line
		    //v alias target

		    struct symtab_HSolveListElement *phsleProto = NULL;

		    //- if model dependency lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_DEPCY_LOOKUP))
		    {
			//- lookup private model, set as alias target

			phsleProto
			    = ParserLookupPrivateModel
			      (/*(PARSERCONTEXT *)pacParserContext,*/$3);

			//- if symbol found

			if (phsleProto)
			{
			    struct symtab_HSolveListElement *phsle
				= SymbolCreateAlias(phsleProto, IdinNewFromChars($4));

			    //- set parameters

			    SymbolAssignParameters(phsle, $5);

			    //- link children

			    if ($6)
			    {
				SymbolAddChild(phsle, $6);

				//- reset actual symbol

				ParserContextSetActual
				    ((PARSERCONTEXT *)pacParserContext, phsle);
			    }

			    //- add private model

			    ParserAddPrivateModel
				((PARSERCONTEXT *)pacParserContext, phsle);
			}

			//- else

			else
			{
			    //- give error msg

			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "PrivateModelsEnumerated",
				 "PrivateModel Symbol(%s) not found.",
				 $3 ? $3 : "NULL");
			}
		    }
		}
	;

PublicModelsSection
	:
	|
		PublicModelsSectionFront
			PublicModelsEnumerated
		PublicModelsSectionEnd
		{
#line
		}
	;

PublicModelsSectionFront
	:
		TOKEN_PUBLIC_MODELS
		{
#line
		    //- clear current element stack

		    ParserCurrentElementPopAll
			((PARSERCONTEXT *)pacParserContext);
		}
	;

PublicModelsSectionEnd
	:
		TOKEN_END TOKEN_PUBLIC_MODELS
		{
#line
		    //! makes private models invisible
		}
	;

PublicModelsEnumerated
	:
	|
		PublicModelsEnumerated
		TOKEN_ORIGIN TOKEN_NUMBER ',' TOKEN_NUMBER ',' TOKEN_NUMBER
	|
		PublicModelsEnumerated
		TOKEN_RELATIVE
/* 	| */
/* 		PublicModelsEnumerated */
/* 		TOKEN_ALGORITHM */
/* 		Identifier */
/* 		TOKEN_ALGORITHMPARAMETERS */
/* 		{ */
/* #line */
/* 		    //- import & init algorithm */

/* 		    //! because TOKEN_ALGORITHMPARAMETERS returns a string, */
/* 		    //! we loose some bytes here */
/* 		    //! perhaps they are on the stack, still needs a check */

/* 		    ParserAlgorithmImport */
/* 			((PARSERCONTEXT *)pacParserContext, */
/* 			 $3, */
/* 			 $4->pcString); */

/* 		    //t algorithm must be event based */
/* 		    //t register interested events from algorithm */
/* 		    //t install algorithm callback */
/* 		} */
/* 		TOKEN_END TOKEN_ALGORITHMPARAMETERS */
	|
		PublicModelsEnumerated
		AnySymbol
		{
#line
		    //- add symbol to models

		    ParserAddPublicModel
			((PARSERCONTEXT *)pacParserContext,
			 $2);
		}
	|
		PublicModelsEnumerated

		/* export model from private models	*/

		TOKEN_ALIAS
			Identifier
			Identifier
			OptionalItemParameters
			OptionalChildSectionOptionalInputOptionalParameters
		TOKEN_END TOKEN_ALIAS
		{
#line
		    //v alias target

		    struct symtab_HSolveListElement *phsleProto = NULL;

		    //- if private model lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_PRIVATE_LOOKUP))
		    {
			//- lookup private model, set as alias target

			phsleProto
			    = ParserLookupPrivateModel
			      (/*(PARSERCONTEXT *)pacParserContext,*/$3);

			//- if symbol found

			if (phsleProto)
			{
			    struct symtab_HSolveListElement *phsle
				= SymbolCreateAlias(phsleProto, IdinNewFromChars($4));

			    //- set parameters

			    SymbolAssignParameters(phsle, $5);

			    //- link children

			    if ($6)
			    {
				SymbolAddChild(phsle, $6);

				//- reset actual symbol

				ParserContextSetActual
				    ((PARSERCONTEXT *)pacParserContext, phsle);
			    }

			    //- add model

			    ParserAddPublicModel
				((PARSERCONTEXT *)pacParserContext, phsle);
			}

			//- else

			else
			{
			    //- give error msg

			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "PublicModelsEnumerated",
				 "PrivateModel Symbol(%s) not found.",
				 $3 ? $3 : "NULL");
			}
		    }
		}
	;

/*
** Symbol propagation with default semantic rule
**
** this applies to .*Symbol and to .*Component
*/

AnySymbol	/* <phsle> */
	:
		AttachmentSymbol
	|
		AxonHillockSymbol
	|
		CellSymbol
	|
		ChannelSymbol
	|
		ConcentrationGateKineticSymbol
	|
		ConnectionSymbol
	|
		ContourPointSymbol
	|
		EMContourSymbol
	|
		EquationExponentialSymbol
	|
		FiberSymbol
	|
		GateKineticBackwardSymbol
	|
		GateKineticForwardSymbol
	|
		GateKineticPartSymbol
	|
		GroupSymbol
	|
		GroupedParametersSymbol
	|
		HHGateSymbol
	|
		NetworkSymbol
	|
		PoolSymbol
	|
		PopulationSymbol
	|
		ProjectionSymbol
	|
		RandomvalueSymbol
	|
		SegmentSymbol
	|
		VConnectionSymbolSymbol
	|
		VContourSymbol
	|
		VSegmentSymbol
	;


AttachmentSymbol
	:
		AttachmentSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

AxonHillockSymbol
	:
		AxonHillockSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->segr.bio.ioh.iol.hsle;
		}
	;

CellSymbol
	:
		CellSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->segr.bio.ioh.iol.hsle;
		}
	;

ChannelSymbol
	:
		ChannelSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

ConcentrationGateKineticSymbol
	:
		ConcentrationGateKineticSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

ConnectionSymbol
	:
		ConnectionSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

ContourPointSymbol
	:
		ContourPointSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

EMContourSymbol
	:
		EMContourSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

EquationExponentialSymbol
	:
		EquationExponentialSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

FiberSymbol
	:
		FiberSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->segr.bio.ioh.iol.hsle;
		}
	;

GateKineticBackwardSymbol
	:
		GateKineticBackwardSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

GateKineticForwardSymbol
	:
		GateKineticForwardSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

GateKineticPartSymbol
	:
		GateKineticPartSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

GroupedParametersSymbol
	:
		GroupedParametersSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

GroupSymbol
	:
		GroupSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

HHGateSymbol
	:
		HHGateSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

NetworkSymbol
	:
		NetworkSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->segr.bio.ioh.iol.hsle;
		}
	;

PoolSymbol
	:
		PoolSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

PopulationSymbol
	:
		PopulationSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->segr.bio.ioh.iol.hsle;
		}
	;

ProjectionSymbol
	:
		ProjectionSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

RandomvalueSymbol
	:
		RandomvalueSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->bio.ioh.iol.hsle;
		}
	;

SegmentSymbol
	:
		SegmentSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->segr.bio.ioh.iol.hsle;
		}
	;

VConnectionSymbolSymbol
	:
		VConnectionSymbolSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->vect.bio.ioh.iol.hsle;
		}
	;

VContourSymbol
	:
		VContourSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->vect.bio.ioh.iol.hsle;
		}
	;

VSegmentSymbol
	:
		VSegmentSection
		{
#line
		    //- put symbol table element on stack

		    $$ = &$1->vect.bio.ioh.iol.hsle;
		}
	;

AxonHillockComponent
	:
		SegmentSymbol
	|
		VSegmentSymbol
	;


CellComponent
	:
		AxonHillockSymbol
	|
		SegmentSymbol
	|
		VSegmentSymbol
	;


ChannelComponent
	:
		AttachmentSymbol
	|
		EquationExponentialSymbol
	|
		HHGateSymbol
	;


EMContourComponent
	:
		ContourPointSymbol
	;


GateKineticBackwardComponent
	:
		GateKineticPartSymbol
	;


GateKineticForwardComponent
	:
		GateKineticPartSymbol
	;


GateKineticPartComponent
	:
		GateKineticPartSymbol
	;


HHGateComponent
	:
		ConcentrationGateKineticSymbol
	|
		GateKineticBackwardSymbol
	|
		GateKineticForwardSymbol
	|
		GateKineticPartSymbol
	;


NetworkComponent
	:
		CellSymbol
	|
		PopulationSymbol
	|
		ProjectionSymbol
	|
		NetworkSymbol
	;


PopulationComponent
	:
		CellSymbol
	|
		RandomvalueSymbol
	;


ProjectionComponent
	:
		VConnectionSymbolSymbol
	|
		ProjectionSymbol
	;


RandomvalueComponent
	:
		AttachmentSymbol
	;


SegmentComponent
	:
		AttachmentSymbol
	|
		PoolSymbol
	|
		ChannelSymbol
	;


VConnectionSymbolComponent
	:
		ConnectionSymbol
	;


VContourComponent
	:
		EMContourSymbol
	;


VSegmentComponent
	:
		SegmentSymbol
	|
		VSegmentSymbol
	;


AxonHillockDescription	/* <paxhi> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = AxonHillockCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->segr.bio.ioh.iol.hsle);
		}
	|
		AxonHillockDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		AxonHillockDescription
		AxonHillockComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		AxonHillockDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

AxonHillockSectionEnd
	:
		EndPushedPidin
		TOKEN_AXON_HILLOCK
		{
#line
		}
	;

AxonHillockSectionFront	/* <pidin> */
	:
		TOKEN_AXON_HILLOCK
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

AxonHillockSection	/* <paxhi> */
	:
		AxonHillockSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			AxonHillockDescription
		AxonHillockSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->segr.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->segr.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->segr.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

CellDescription	/* <pcell> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = CellCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->segr.bio.ioh.iol.hsle);
		}
	|
		CellDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		CellDescription
		CellComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		CellDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

CellSectionEnd
	:
		EndPushedPidin
		TOKEN_CELL
		{
#line
		}
	;

CellSectionFront	/* <pidin> */
	:
		TOKEN_CELL
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

CellSection	/* <pcell> */
	:
		CellSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			CellDescription
		CellSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->segr.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->segr.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->segr.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

ChannelDescription	/* <pchan> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = ChannelCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		ChannelDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		ChannelDescription
		ChannelComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		ChannelDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	|
		TOKEN_TABLEFILE
		TOKEN_STRING
		{
#line
		    //- remove ending '"' from string

		    $2->pcString[$2->iLength - 1] = '\0';

		    //- put channel description on stack

		    $$ = ChannelCalloc();

		    //- fill in table parameters

		    ChannelSetTableParameters
			($$,
			 (PARSERCONTEXT *)pacParserContext,
			 &$2->pcString[1]);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);

		    //! memory leak : $2
		}
	;

ChannelSectionEnd
	:
		EndPushedPidin
		TOKEN_CHANNEL
		{
#line
		}
	;

ChannelSectionFront	/* <pidin> */
	:
		TOKEN_CHANNEL
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

ChannelSection	/* <pchan> */
	:
		ChannelSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			ChannelDescription
		ChannelSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

ConcentrationGateKineticDescription	/* <pcgatk> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = ConcentrationGateKineticCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		ConcentrationGateKineticDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		ConcentrationGateKineticDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

ConcentrationGateKineticSectionEnd
	:
		EndPushedPidin
		TOKEN_CONCENTRATION_GATE_KINETIC
		{
#line
		}
	;

ConcentrationGateKineticSectionFront	/* <pidin> */
	:
		TOKEN_CONCENTRATION_GATE_KINETIC
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

ConcentrationGateKineticSection	/* <pcgatk> */
	:
		ConcentrationGateKineticSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			ConcentrationGateKineticDescription
		ConcentrationGateKineticSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

ConnectionDescription	/* <pconsy> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = ConnectionSymbolCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		ConnectionDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		ConnectionDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

ConnectionSectionEnd
	:
		EndPushedPidin
		TOKEN_CONNECTION
		{
#line
		}
	;

ConnectionSectionFront	/* <pidin> */
	:
		TOKEN_CONNECTION
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

ConnectionSection	/* <pconsy> */
	:
		ConnectionSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			ConnectionDescription
		ConnectionSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

ContourPointDescription	/* <pcpnt> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = ContourPointCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		ContourPointDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		ContourPointDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

ContourPointSectionEnd
	:
		EndPushedPidin
		TOKEN_CONTOUR_POINT
		{
#line
		}
	;

ContourPointSectionFront	/* <pidin> */
	:
		TOKEN_CONTOUR_POINT
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

ContourPointSection	/* <pcpnt> */
	:
		ContourPointSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			ContourPointDescription
		ContourPointSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

EMContourDescription	/* <pemc> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = EMContourCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		EMContourDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		EMContourDescription
		EMContourComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		EMContourDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

EMContourSectionEnd
	:
		EndPushedPidin
		TOKEN_EM_CONTOUR
		{
#line
		}
	;

EMContourSectionFront	/* <pidin> */
	:
		TOKEN_EM_CONTOUR
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

EMContourSection	/* <pemc> */
	:
		EMContourSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			EMContourDescription
		EMContourSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

EquationExponentialDescription	/* <peqe> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = EquationExponentialCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		EquationExponentialDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		EquationExponentialDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

EquationExponentialSectionEnd
	:
		EndPushedPidin
		TOKEN_EQUATION_EXPONENTIAL
		{
#line
		}
	;

EquationExponentialSectionFront	/* <pidin> */
	:
		TOKEN_EQUATION_EXPONENTIAL
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

EquationExponentialSection	/* <peqe> */
	:
		EquationExponentialSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			EquationExponentialDescription
		EquationExponentialSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

FiberDescription	/* <pfibr> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = FiberCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->segr.bio.ioh.iol.hsle);
		}
	|
		FiberDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		FiberDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

FiberSectionEnd
	:
		EndPushedPidin
		TOKEN_FIBER
		{
#line
		}
	;

FiberSectionFront	/* <pidin> */
	:
		TOKEN_FIBER
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

FiberSection	/* <pfibr> */
	:
		FiberSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			FiberDescription
		FiberSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->segr.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->segr.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->segr.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

GateKineticBackwardDescription	/* <pgatk> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = GateKineticCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		GateKineticBackwardDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		GateKineticBackwardDescription
		GateKineticBackwardComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		GateKineticBackwardDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

GateKineticBackwardSectionEnd
	:
		EndPushedPidin
		TOKEN_GATE_KINETIC_B
		{
#line
		}
	;

GateKineticBackwardSectionFront	/* <pidin> */
	:
		TOKEN_GATE_KINETIC_B
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

GateKineticBackwardSection	/* <pgatk> */
	:
		GateKineticBackwardSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			GateKineticBackwardDescription
		GateKineticBackwardSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

GateKineticForwardDescription	/* <pgatk> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = GateKineticCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		GateKineticForwardDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		GateKineticForwardDescription
		GateKineticForwardComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		GateKineticForwardDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

GateKineticForwardSectionEnd
	:
		EndPushedPidin
		TOKEN_GATE_KINETIC_A
		{
#line
		}
	;

GateKineticForwardSectionFront	/* <pidin> */
	:
		TOKEN_GATE_KINETIC_A
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

GateKineticForwardSection	/* <pgatk> */
	:
		GateKineticForwardSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			GateKineticForwardDescription
		GateKineticForwardSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

GateKineticPartDescription	/* <pgatk> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = GateKineticCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		GateKineticPartDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		GateKineticPartDescription
		GateKineticPartComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		GateKineticPartDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

GateKineticPartSectionEnd
	:
		EndPushedPidin
		TOKEN_GATE_KINETIC_PART
		{
#line
		}
	;

GateKineticPartSectionFront	/* <pidin> */
	:
		TOKEN_GATE_KINETIC_PART
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

GateKineticPartSection	/* <pgatk> */
	:
		GateKineticPartSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			GateKineticPartDescription
		GateKineticPartSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

GroupDescription	/* <pgrup> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = GroupCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		GroupDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		GroupDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

GroupedParametersDescription	/* <pgrpp> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = GroupedParametersCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		GroupedParametersDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		GroupedParametersDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

GroupedParametersSectionEnd
	:
		EndPushedPidin
		TOKEN_GROUPED_PARAMETERS
		{
#line
		}
	;

GroupedParametersSectionFront	/* <pidin> */
	:
		TOKEN_GROUPED_PARAMETERS
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

GroupedParametersSection	/* <pgrpp> */
	:
		GroupedParametersSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			GroupedParametersDescription
		GroupedParametersSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

GroupSectionEnd
	:
		EndPushedPidin
		TOKEN_GROUP
		{
#line
		}
	;

GroupSectionFront	/* <pidin> */
	:
		TOKEN_GROUP
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

GroupSection	/* <pgrup> */
	:
		GroupSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			GroupDescription
		GroupSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

HHGateDescription	/* <pgathh> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = HHGateCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		HHGateDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		HHGateDescription
		HHGateComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		HHGateDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

HHGateSectionEnd
	:
		EndPushedPidin
		TOKEN_HH_GATE
		{
#line
		}
	;

HHGateSectionFront	/* <pidin> */
	:
		TOKEN_HH_GATE
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

HHGateSection	/* <pgathh> */
	:
		HHGateSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			HHGateDescription
		HHGateSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

NetworkDescription	/* <pnetw> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = NetworkCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->segr.bio.ioh.iol.hsle);
		}
	|
		NetworkDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		NetworkDescription
		NetworkComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		NetworkDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

NetworkSectionEnd
	:
		EndPushedPidin
		TOKEN_NETWORK
		{
#line
		}
	;

NetworkSectionFront	/* <pidin> */
	:
		TOKEN_NETWORK
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

NetworkSection	/* <pnetw> */
	:
		NetworkSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			NetworkDescription
		NetworkSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->segr.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->segr.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->segr.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

PoolDescription	/* <ppool> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = PoolCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		PoolDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		PoolDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

PoolSectionEnd
	:
		EndPushedPidin
		TOKEN_POOL
		{
#line
		}
	;

PoolSectionFront	/* <pidin> */
	:
		TOKEN_POOL
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

PoolSection	/* <ppool> */
	:
		PoolSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			PoolDescription
		PoolSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

PopulationDescription	/* <ppopu> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = PopulationCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->segr.bio.ioh.iol.hsle);
		}
	|
		PopulationDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		PopulationDescription
		PopulationComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		PopulationDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

PopulationSectionEnd
	:
		EndPushedPidin
		TOKEN_POPULATION
		{
#line
		}
	;

PopulationSectionFront	/* <pidin> */
	:
		TOKEN_POPULATION
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

PopulationSection	/* <ppopu> */
	:
		PopulationSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			PopulationDescription
		PopulationSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->segr.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->segr.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->segr.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

ProjectionDescription	/* <pproj> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = ProjectionCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		ProjectionDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		ProjectionDescription
		ProjectionComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		ProjectionDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

ProjectionSectionEnd
	:
		EndPushedPidin
		TOKEN_PROJECTION
		{
#line
		}
	;

ProjectionSectionFront	/* <pidin> */
	:
		TOKEN_PROJECTION
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

ProjectionSection	/* <pproj> */
	:
		ProjectionSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			ProjectionDescription
		ProjectionSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

RandomvalueDescription	/* <pranv> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = RandomvalueCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		RandomvalueDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		RandomvalueDescription
		RandomvalueComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		RandomvalueDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

RandomvalueSectionEnd
	:
		EndPushedPidin
		TOKEN_RANDOMVALUE
		{
#line
		}
	;

RandomvalueSectionFront	/* <pidin> */
	:
		TOKEN_RANDOMVALUE
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

RandomvalueSection	/* <pranv> */
	:
		RandomvalueSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			RandomvalueDescription
		RandomvalueSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

SegmentDescription	/* <psegment> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = SegmentCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->segr.bio.ioh.iol.hsle);
		}
	|
		SegmentDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		SegmentDescription
		SegmentComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		SegmentDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->segr.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	|
		SegmentDescription
		TOKEN_OPTIONS
		SegmentInstanceOptions
		{
#line
		    //- set segment options

		    SymbolSetOptions(&$1->segr.bio.ioh.iol.hsle, $3);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->segr.bio.ioh.iol.hsle);

		    //- push segment description on stack

		    $$ = $1;
		}
	;

SegmentSectionEnd
	:
		EndPushedPidin
		TOKEN_SEGMENT
		{
#line
		}
	;

SegmentSectionFront	/* <pidin> */
	:
		TOKEN_SEGMENT
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

SegmentSection	/* <psegment> */
	:
		SegmentSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			SegmentDescription
		SegmentSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->segr.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->segr.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->segr.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

SegmentInstanceOptions	/* <iCompOptions> */
	:
		{
#line
		    //- erase int on stack

		    $$ = 0;
		}
	|
		SegmentInstanceOptions
		TOKEN_SPHERICAL
		{
#line
		    //- remember spherical option

		    $$ |= FLAG_SEGMENTER_SPHERICAL;
		}
	|
		SegmentInstanceOptions
		TOKEN_CYLINDRICAL
		{
#line
		    //- remember cylindrical option (erases spherical option)

		    $$ &= ~(FLAG_SEGMENTER_SPHERICAL);
		}
	;

VConnectionSymbolDescription	/* <pvconsy> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = VConnectionSymbolCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->vect.bio.ioh.iol.hsle);
		}
	|
		VConnectionSymbolDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->vect.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		VConnectionSymbolDescription
		VConnectionSymbolComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->vect.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		VConnectionSymbolDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->vect.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

VConnectionSymbolSectionEnd
	:
		EndPushedPidin
		TOKEN_CONNECTION_GROUP
		{
#line
		}
	;

VConnectionSymbolSectionFront	/* <pidin> */
	:
		TOKEN_CONNECTION_GROUP
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

VConnectionSymbolSection	/* <pvconsy> */
	:
		VConnectionSymbolSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			VConnectionSymbolDescription
		VConnectionSymbolSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->vect.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->vect.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->vect.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

VContourDescription	/* <pvcont> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = VContourCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->vect.bio.ioh.iol.hsle);
		}
	|
		VContourDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->vect.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		VContourDescription
		VContourComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->vect.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		VContourDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->vect.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

VContourSectionEnd
	:
		EndPushedPidin
		TOKEN_CONTOUR_GROUP
		{
#line
		}
	;

VContourSectionFront	/* <pidin> */
	:
		TOKEN_CONTOUR_GROUP
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

VContourSection	/* <pvcont> */
	:
		VContourSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			VContourDescription
		VContourSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->vect.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->vect.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->vect.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

VSegmentDescription	/* <pvsegm> */
	:
		{
#line
		    //- prepare struct for symbol table

		    $$ = VSegmentCalloc();

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->vect.bio.ioh.iol.hsle);
		}
	|
		VSegmentDescription
		ChildSectionOptionalInputOptionalParameters
		{
#line
		    //- link children

		    if ($2)
		    {
			SymbolAddChild(&$1->vect.bio.ioh.iol.hsle, $2);
		    }

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- put symbol description on stack

		    $$ = $1;
		}
	|
		VSegmentDescription
		VSegmentComponent
		{
#line
		    //- add component to current section list

		    SymbolAddChild(&$1->vect.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- push current description on stack

		    $$ = $1;
		}
	|
		VSegmentDescription
		Parameters
		{
#line
		    //- link parameters

		    SymbolParameterLinkAtEnd(&$1->vect.bio.ioh.iol.hsle, $2);

		    //- reset actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$1->vect.bio.ioh.iol.hsle);

		    //- put symbol on stack

		    $$ = $1;
		}
	;

VSegmentSectionEnd
	:
		EndPushedPidin
		TOKEN_SEGMENT_GROUP
		{
#line
		}
	;

VSegmentSectionFront	/* <pidin> */
	:
		TOKEN_SEGMENT_GROUP
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

VSegmentSection	/* <pvsegm> */
	:
		VSegmentSectionFront
			InputOutputRelations
			OptionalItemInputRelations
			VSegmentDescription
		{
		    //- get current context

		    struct PidinStack *ppist
			= ParserContextGetPidinContext
			  ((PARSERCONTEXT *)pacParserContext);

		    //- recompute relative coordinates to absolute coordinates

		    VSegmentRelative2Absolute($4, ppist);
		}
		VSegmentSectionEnd
		{
#line
		    //- assign name to symbol

		    SymbolSetName(&$4->vect.bio.ioh.iol.hsle, $1);

		    //- link input/output relations

		    SymbolAssignBindableIO(&$4->vect.bio.ioh.iol.hsle, $2);

		    //- bind I/O relations

		    SymbolAssignInputs(&$4->vect.bio.ioh.iol.hsle, $3);

		    //- put finished section info on stack

		    $$ = $4;
		}
	;

AttachmentSectionEnd
	:
		EndPushedPidin
		TOKEN_ATTACHMENT
		{
#line
		}
	;

AttachmentSectionFront	/* <pidin> */
	:
		TOKEN_ATTACHMENT
		IdentifierOptionIndexPushedPidin
		{
#line
		    //- put identifier on stack

		    $$ = $2;
		}
	;

AttachmentSection	/* <patta> */
	:
		AttachmentSectionFront
			InputOutputRelations
			AttachmentDescription
		AttachmentSectionEnd
		{
#line
		    //- link name

		    SymbolSetName(&$3->bio.ioh.iol.hsle, $1);

		    //- set type of attachment

		    if (strcasecmp(IdinName($1), "spikegen") == 0)
		    {
			AttachmentSetType($3, TYPE_ATTACHMENT_OUTGOING);
		    }
		    else if (strcasecmp(IdinName($1), "synapse") == 0)
		    {
			AttachmentSetType($3, TYPE_ATTACHMENT_INCOMING);
		    }
		    else
		    {
			//- give diagnostics : unrecognized attachment type

			NeurospacesError
			    ((PARSERCONTEXT *)pacParserContext,
			     "AttachmentSection",
			     "Unrecognized attachment type(%s).",
			     IdinName($1)
			     ? IdinName($1)
			     : "No type");
		    }

		    //- link I/O relations

		    SymbolAssignBindableIO(&$3->bio.ioh.iol.hsle, $2);

		    //- put attachment point description on stack

		    $$ = $3;
		}
	;

AttachmentDescription	/* <patta> */
	:
		AttachmentData
		{
#line
		    //- allocate attachment point on stack

		    $$ = AttachmentCalloc();

/* 		    //- set type : outgoing */

/* 		    AttachmentSetType($$, TYPE_ATTACHMENT_OUTGOING); */

		    //- assign attributes

		    SymbolAssignParameters(&$$->bio.ioh.iol.hsle, $1);

		    //- set datatype

		    AttachmentSetDataType($$, "null data");

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		AttachmentIncoming
		AttachmentData
		{
#line
		    //- allocate attachment point on stack

		    $$ = AttachmentCalloc();

		    //- set type : incoming

		    AttachmentSetType($$, TYPE_ATTACHMENT_INCOMING);

		    //- assign attributes

		    SymbolAssignParameters(&$$->bio.ioh.iol.hsle, $2);

		    //- set datatype

		    AttachmentSetDataType($$, $1);

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	|
		AttachmentOutgoing
		AttachmentData
		{
#line
		    //- allocate attachment point on stack

		    $$ = AttachmentCalloc();

		    //- set type : outgoing

		    AttachmentSetType($$, TYPE_ATTACHMENT_OUTGOING);

		    //- assign attributes

		    SymbolAssignParameters(&$$->bio.ioh.iol.hsle, $2);

		    //- set datatype

		    AttachmentSetDataType($$, $1);

		    //- set actual symbol

		    ParserContextSetActual
			((PARSERCONTEXT *)pacParserContext,
			 &$$->bio.ioh.iol.hsle);
		}
	;

AttachmentData	/* <ppar> */
	:
		{
#line
		    //- put NULL attributes on stack

		    $$ = NULL;
		}
	|
		AttachmentAttributes
		{
#line
		    //- put attributes on stack

		    $$ = $1;
		}
	;

AttachmentAttributes	/* <ppar> */
	:
		TOKEN_ATTRIBUTES
			Attributes
		TOKEN_END TOKEN_ATTRIBUTES
		{
#line
		    //- put attributes on stack

		    $$ = $2->pparFirst;
		}
	;


AttachmentIncoming	/* <pcIdentifier> */
	:
		TOKEN_RECEIVES TOKEN_EVENTS '(' Identifier ')'
		{
#line
		    //- put identifier on stack

		    $$ = $4;
		}
	;

AttachmentOutgoing	/* <pcIdentifier> */
	:
		TOKEN_GENERATES TOKEN_EVENTS '(' Identifier ')'
		{
#line
		    //- put identifier on stack

		    $$ = $4;
		}
	;

ChildSectionFront	/* <phsle> */
	:
		TOKEN_CHILD
		Identifier
		IdentifierOptionIndex
		{
#line
		    //v prototype symbol

		    struct symtab_HSolveListElement *phslePrototype = NULL;

		    //- if public model lookup not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_PUBLIC_LOOKUP))
		    {
			//- if lookup prototype

			phslePrototype = ParserLookupPrivateModel($2);

			if (!phslePrototype)
			{
			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "ChildSectionFront",
				 "Private Model (%s) not found.",
				 $2);

			    $$ = NULL;
			}
			else if (!instanceof_bio_comp(phslePrototype))
			{
			    NeurospacesError
				((PARSERCONTEXT *)pacParserContext,
				 "ChildSectionFront",
				 "Private Model (%s) is not a bio component.",
				 $2);

			    $$ = NULL;
			}
			else
			{
			    //- allocate id for new symbol

			    struct symtab_IdentifierIndex *pidin = IdinCalloc();

			    IdinSetName(pidin, $2);

			    //- new symbol is alias for prototype

			    $$ = SymbolCreateAlias(phslePrototype, $3);
			}
		    }
		    else
		    {
			//! so for this particular case, NULL does not
			//! signal an error, could become complicated in
			//! the future, perhaps another solution is
			//! needed with dummy symbols or something ?

			$$ = NULL;
		    }
		}
	;

ChildSectionEnd
	:
		TOKEN_END TOKEN_CHILD
		{
#line
		}
	;

OptionalChildSectionOptionalInputOptionalParameters	/* <phsle> */
	:
		{
#line
		    //- put no symbol on stack

		    $$ = NULL;
		}
	|
		ChildSectionOptionalInputOptionalParameters
	;

ChildSectionOptionalInputOptionalParameters	/* <phsle> */
	:
		ChildSectionFront
			FixedItemInputRelations
			ItemParameters
		ChildSectionEnd
		{
#line
		    //- fill in values of bio component

		    if ($1)
		    {
			SymbolAssignInputs($1, $2 ? $2->pioFirst : NULL);

			SymbolAssignParameters($1, $3);
		    }

		    //- put bio component on stack

		    $$ = $1;
		}
	|
		ChildSectionFront
			ItemParameters
		ChildSectionEnd
		{
#line
		    //- fill in values of bio component

		    if ($1)
		    {
			SymbolAssignParameters($1, $2);

		    }

		    //- put bio component on stack

		    $$ = $1;
		}
	|
		ChildSectionFront
			FixedItemInputRelations
		ChildSectionEnd
		{
#line
		    //- fill in values of bio component

		    if ($1)
		    {
			SymbolAssignInputs($1, $2 ? $2->pioFirst : NULL);
		    }

		    //- put bio component on stack

		    $$ = $1;
		}
	|
		ChildSectionFront
		ChildSectionEnd
		{
#line
		    //- put bio component on stack

		    $$ = $1;
		}
	;

OptionalItemInputRelations	/* <pio> */
	:
		{
#line
		    $$ = NULL;
		}
	|
		FixedItemInputRelations
	;

FixedItemInputRelations	/* <pio> */
	:
		TOKEN_BINDINGS
		TOKEN_END TOKEN_BINDINGS
		{
#line
		    $$ = NULL;
		}
	|
		TOKEN_BINDINGS
			ItemInputRelations
		TOKEN_END TOKEN_BINDINGS
		{
#line
		    $$ = $2;
		}
	|
		TOKEN_BINDINGS
			ItemInputRelations
			','
		TOKEN_END TOKEN_BINDINGS
		{
#line
		    $$ = $2;
		}
	;

ItemInputRelations	/* <pio> */
	:
		TOKEN_INPUT
		FieldOrIOHierarchical
		{
#line
		    //- allocate I/O relation

		    struct symtab_InputOutput
			*pio = InputOutputNewForType(INPUT_TYPE_INPUT);

		    //- store idin

		    pio->pidinField = $2;

		    //- set TOKEN_INPUT flag for root idin $2

		    IdinSetFlags($2, FLAG_IDENTINDEX_INPUTROOT);

		    //- put io list on stack

		    $$ = pio;
		}
	|
		ItemInputRelations
		','
		TOKEN_INPUT
		FieldOrIOHierarchical
		{
#line
		    //- allocate I/O relation

		    struct symtab_InputOutput *pio
			= InputOutputNewForType(INPUT_TYPE_INPUT);

		    //- set TOKEN_INPUT flag for root idin $4

		    IdinSetFlags($4, FLAG_IDENTINDEX_INPUTROOT);

		    //- store idin

		    pio->pidinField = $4;

		    //- link input relations into list

		    pio->pioFirst = $1->pioFirst;
		    $1->pioNext = pio;

		    //- put io list on stack

		    $$ = pio;
		}
	;

OptionalItemParameters	/* <ppar> */
	:
		{
#line
		    //- put empty parameter list onto top of stack

		    $$ = NULL;
		}
	|
		ItemParameters
		{
#line
		    //- put parameters onto top of stack

		    $$ = $1;
		}
	;

ItemParameters	/* <ppar> */
	:
		Parameters
		{
#line
		    //- put parameters onto top of stack

		    $$ = $1;
		}
	;

Attributes	/* <ppar> */
	:
		Identifier
		{
#line
		    //- allocate parameters on stack

		    $$ = ParameterCalloc();

		    $$->pparFirst = $$;

		    //- fill in name and type

		    ParameterSetAttribute($$);

		    ParameterSetName($$, $1);
		}
	|
		Attributes
		','
		Identifier
		{
#line
		    //- allocate parameters

		    struct symtab_Parameters *ppar = ParameterCalloc();

		    //- fill in name and type

		    ParameterSetAttribute(ppar);

		    ParameterSetName(ppar, $3);

		    //- link new parameter in list

		    $1->pparNext = ppar;
		    ppar->pparFirst = $1->pparFirst;

		    //- push last parameter on stack

		    $$ = $1;
		}
	;

Parameters	/* <ppar> */
	:
		TOKEN_PARAMETERS
			ParametersEnumerated
		TOKEN_END TOKEN_PARAMETERS
		{
#line
		    //- put parameters onto top of stack

		    if ($2)
		    {
			$$ = $2->pparFirst;
		    }
		    else
		    {
			$$ = NULL;
		    }
		}
	;

ParametersEnumerated	/* <ppar> */
	:
		ParametersEnumerated
		','
		Parameter
		{
#line
		    //- allocate room for symbolic parameter

		    $1->pparNext = $3;
		    $3->pparFirst = $1->pparFirst;

		    //- put last parameter onto stack

		    $$ = $3;
		}
	|
		ParametersEnumerated
		','
		{
#line
		    //- allocate room for symbolic parameter

		    $1->pparNext = NULL;

		    //- put last parameter onto stack

		    $$ = $1;
		}
	|
		Parameter
		{
#line
		    //- put last parameter onto stack

		    $$ = $1;
		}
	|
		{
#line
		    //- put no parameters onto stack

		    $$ = NULL;
		}
	;

Parameter	/* <ppar> */
	:
		TOKEN_PARAMETER
		'('
		Identifier
		'='
		IdentifierHierarchicalOptionalRooted
		')'
		{
#line
		    //- allocate room for symbolic parameter

		    $$ = ParameterNewFromPidinQueue($3, $5->pidinRoot, TYPE_PARA_SYMBOLIC);

		}
	|
		TOKEN_PARAMETER
		'('
		Identifier
		'='
		FieldOrIOHierarchical
		')'
		{
#line
		    //- allocate room for symbolic parameter

		    $$ = ParameterNewFromPidinQueue($3, $5, TYPE_PARA_FIELD);

		}
	|
		TOKEN_PARAMETER
		'('
		Identifier
		'='
		TOKEN_STRING
		')'
		{
#line
		    //- allocate room for string parameter

		    //- remove ending '"'

		    $5->pcString[$5->iLength - 1] = '\0';

		    //! allocates to much

		    char *pc = calloc(sizeof(char), $5->iLength);

		    strcpy(pc, &$5->pcString[1]);

		    $$ = ParameterNewFromString($3, pc);

		}
	|
		TOKEN_PARAMETER
		'('
		Identifier
		'='
		TOKEN_NUMBER
		')'
		{
#line
		    //- allocate room for number parameter

		    $$ = ParameterNewFromNumber($3, $5);

		}
	|
		TOKEN_PARAMETER
		'('
		Identifier
		'='
		FunctionSpecification
		')'
		{
#line
		    //- allocate room for function parameter

		    $$ = ParameterNewFromFunction($3, $5);

		}
	;

OptionalComma
	:
		','
	|
	;

FunctionSpecification	/* <pfun> */
	:
		FunctionIdentifier
			'('
			FunctionParameters
			')'
			OptionalComma
		{
#line
		    //- put function with name on stack

		    $$ = FunctionCalloc();

		    FunctionSetName($$, $1);

		    //- remember function has parameters

		    FunctionAssignParameters($$, $3);
		}
	;

FunctionIdentifier	/* <pcIdentifier> */
	:
		Identifier
		{
#line
		    //- put function identifier on stack

		    $$ = $1;
		}
	;

FunctionParameters	/* <ppar> */
	:
		ParametersEnumerated
		{
#line
		    //- put parameters on stack

		    if ($1)
		    {
			$$ = $1->pparFirst;
		    }
		    else
		    {
			$$ = NULL;
		    }
		}
	;

InputOutputRelations	/* <pioc> */
	:
		{
#line
		    //- remember relations in container on stack

		    $$ = IOContainerNewFromIO(NULL);
		}
	|
		TOKEN_BINDABLES
			InputRelations
		TOKEN_END TOKEN_BINDABLES
		{
#line
		    //- remember relations in container on stack

		    $$ = IOContainerNewFromIO($2->pioFirst);
		}
	|
		TOKEN_BINDABLES
			OutputRelations
		TOKEN_END TOKEN_BINDABLES
		{
#line
		    //- remember relations in container on stack

		    $$ = IOContainerNewFromIO($2->pioFirst);
		}
	|
		TOKEN_BINDABLES
			InputRelations
			','
			OutputRelations
		TOKEN_END TOKEN_BINDABLES
		{
#line
		    //- link relations together

		    $2->pioNext = $4;

		    //t loop over output relations and set ->pioFirst ?

		    //- remember relations in container on stack

		    $$ = IOContainerNewFromIO($2->pioFirst);
		}
	;

InputRelations	/* <pio> */
	:
		InputRelations
		','
		TOKEN_INPUT
		FieldOrIO
		{
#line
		    //- allocate new input specification

		    struct symtab_InputOutput *pio
			= InputOutputNewForType(INPUT_TYPE_INPUT);

		    pio->pidinField = $4;

		    //- link input list

		    $1->pioNext = pio;
		    pio->pioFirst = $1->pioFirst;

		    //- put new item on top of stack

		    $$ = pio;
		}
	|
		TOKEN_INPUT
		FieldOrIO
		{
#line
		    //- allocate input specification on stack

		    $$ = InputOutputNewForType(INPUT_TYPE_INPUT);

		    $$->pidinField = $2;
		}
	;

OutputRelations	/* <pio> */
	:
		OutputRelations
		','
		TOKEN_OUTPUT
		FieldOrIOOptionalHierarchical
		{
#line
		    //- allocate new input specification

		    struct symtab_InputOutput *pio
			= InputOutputNewForType(INPUT_TYPE_OUTPUT);

		    pio->pidinField = $4;

		    //- link input list

		    $1->pioNext = pio;
		    pio->pioFirst = $1->pioFirst;

		    //- put new item on top of stack

		    $$ = pio;
		}
	|
		TOKEN_OUTPUT
		FieldOrIOOptionalHierarchical
		{
#line
		    //- allocate input specification on stack

		    $$ = InputOutputNewForType(INPUT_TYPE_OUTPUT);

		    $$->pidinField = $2;
		}
	;

FieldOrIOOptionalHierarchical	/* <pidin> */
	:
		FieldOrIO
		{
#line
		    //- remember field idin on stack

		    $$ = $1;
		}
	|
		FieldOrIOHierarchical
		{
#line
		    //- remember field idin on stack

		    $$ = $1;
		}
	;

FieldOrIOHierarchical	/* <pidin> */
	:
		IdentifierHierarchical
		TOKEN_DEREFERENCE
		Field
		{
#line
		    //- assign root for field

		    $3->pidinRoot = $1->pidinRoot;

		    //- link structures in list

		    $1->pidinNext = $3;

		    //- remember root idin on stack

		    //t we could set a flag here that says pidin is field

		    $$ = $3->pidinRoot;
		}
	|
		IdentifierHierarchical
		TOKEN_IOSELECT
		IO
		{
#line
		    //- assign root for field

		    $3->pidinRoot = $1->pidinRoot;

		    //- link structures in list

		    $1->pidinNext = $3;

		    //- remember root idin on stack

		    //t we could set a flag here that says pidin is field

		    $$ = $3->pidinRoot;
		}
	;

FieldOrIO	/* <pidin> */
	:
		Field
		{
#line
		    //- put field idin on stack

		    $$ = $1;
		}
	|
		IO
		{
#line
		    //- put IO idin on stack

		    $$ = $1;
		}
	;

Field	/* <pidin> */
	:
		Identifier
		{
#line
		    //- put field idin on stack

		    $$ = IdinCalloc();

		    IdinSetFlags($$, FLAG_IDENTINDEX_FIELD);

		    $$->pcIdentifier = $1;
		}
	;

IO	/* <pidin> */
	:
		Identifier
		';'
		{
#line
		    //- put field idin on stack

		    $$ = IdinCalloc();

		    IdinSetFlags($$, FLAG_IDENTINDEX_IO);

		    $$->pcIdentifier = $1;
		}
	;

IdentifierHierarchicalNameSpaceRooted	/* <pidin> */
	:
		Identifier
		TOKEN_NAMESPACESEPERATOR
		TOKEN_HIERARCHICALSEPERATOR
		IdentifierOptionIndex
		{
#line
		    //- remember id and range

		    $$ = IdinCalloc();

		    $$->pcIdentifier = $1;

		    //- remember idin is namespaced

		    IdinSetNamespaced($$);

		    //- remember idin is rooted

		    IdinSetRooted($4);

		    //- link with rooted idins

		    $$->pidinNext = $4;
		    $4->pidinRoot = $$;
		}
/*
** path more than one deep
**
** selects subitems in namespace
**
	|
		Identifier
		TOKEN_NAMESPACESEPERATOR
		IdentifierHierarchicalRooted
		{
		    $$ = NULL;

		    //t not supported yet.

		    *(int *)NULL = 0xdeadbeaf;
		}
*/
	;

IdentifierHierarchicalRooted	/* <pidin> */
	:
		TOKEN_HIERARCHICALSEPERATOR
		IdentifierHierarchical
		{
#line
		    //- remember idin list is rooted

		    IdinSetRooted($2->pidinRoot);

		    //- pass idin onto stack

		    $$ = $2;
		}
	;

IdentifierHierarchicalOptionalRooted	/* <pidin> */
	:
		IdentifierHierarchical
	|
		IdentifierHierarchicalRooted
	;

/*
** top : last parsed idin
*/

IdentifierHierarchical	/* <pidin> */
	:
		IdentifierOptionIndex
		{
#line
		    //- assign root of identifier list

		    $1->pidinRoot = $1;

		    //- remember idin on stack

		    $$ = $1;
		}
	|
		IdentifierHierarchical
		TOKEN_HIERARCHICALSEPERATOR
		IdentifierOptionIndex
		{
#line
		    //- assign root for last identifier

		    $3->pidinRoot = $1->pidinRoot;

		    //- link structures in list

		    $1->pidinNext = $3;

		    //- remember last idin on stack

		    $$ = $3;
		}
	;

IdentifierOptionIndex	/* <pidin> */
	:
		TOKEN_PARENT_SYMBOL
		{
#line
		    //- set flags with parent indicator

		    $$ = IdinCalloc();

		    IdinSetFlags($$, FLAG_IDENTINDEX_PARENT);
		}
	|
		TOKEN_CURRENT_SYMBOL
		{
#line
		    //- set flags with current indicator

		    $$ = IdinCalloc();

		    IdinSetFlags($$, FLAG_IDENTINDEX_CURRENT);
		}
	|
		Identifier
		{
#line
		    //- set flags : no index, remember id

		    $$ = IdinCalloc();

		    IdinSetFlags($$, FLAG_IDENTINDEX_NOINDEX);

		    $$->pcIdentifier = $1;
		}
	;

/*
** shift & reduce algorithm list
**
** Algorithm info is pushed on parsercontext state stack
*/

AlgorithmListPush
	:
		{
#line
		    //- push start of algorithmlist marker

		    ParserContextPushAlgorithmState(PARSERSTATE_START_ALGORITHMS);
		}
	|
		AlgorithmListPush
		TOKEN_ALGORITHM
			Identifier
			Identifier
			OptionalItemParameters
		TOKEN_END TOKEN_ALGORITHM
		{
#line
		    //- if algorithm handlers are not disabled by the options

		    if (!(((PARSERCONTEXT *)pacParserContext)
			  ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_ALGORITHM_HANDLING))

		    {
			//- import & init algorithm

			//! because TOKEN_ALGORITHMPARAMETERS returns a string,
			//! we loose some bytes here
			//! perhaps they are on the stack, still needs a check

			//t error checking

			struct symtab_AlgorithmSymbol *palgs
			    = AlgorithmSymbolCalloc();

			AlgorithmSymbolAssignParameters(palgs, $5);

			struct AlgorithmInstance *palgi
			    = ParserAlgorithmImport
			      ((PARSERCONTEXT *)pacParserContext,
			       $3,
			       $4,
			       NULL,
			       $5,
			       palgs);

			AlgorithmSymbolSetAlgorithmInstance(palgs, palgi);

			ParserContextPushAlgorithmState(palgs);
			ParserContextPushAlgorithmState(palgi);
			ParserContextPushAlgorithmState($3);
			ParserContextPushAlgorithmState($4);
			ParserContextPushAlgorithmState(NULL);

			ParserContextPushAlgorithmState(PARSERSTATE_ALGORITHM);
		    }
		}
	;

/*
** pop a algorithm list
*/

AlgorithmListPop
	:
		{
#line
		    void *pvState;

		    //- while algorithms on context stack

		    while ((pvState = ParserContextPopAlgorithmState())
			   != PARSERSTATE_START_ALGORITHMS)
		    {
			//- pop algorithm info

			char *pcInit = (char *)ParserContextPopAlgorithmState();
			char *pcInstance = (char *)ParserContextPopAlgorithmState();
			char *pcName = (char *)ParserContextPopAlgorithmState();
			struct AlgorithmInstance *palgi
			    = (struct AlgorithmInstance *)
			      ParserContextPopAlgorithmState();

			struct symtab_AlgorithmSymbol *palgs
			    = (struct symtab_AlgorithmSymbol *)
			      ParserContextPopAlgorithmState();

			//- if algorithm handlers are not disabled by the options

			if (!(((PARSERCONTEXT *)pacParserContext)
			      ->pneuro->pnsc->nso.iFlags & NSOFLAG_DISABLE_ALGORITHM_HANDLING))
			{
			    //- call algorithm on current symbol

			    ParserAlgorithmHandle
				((PARSERCONTEXT *)pacParserContext,
				 ParserContextGetActual
				 ((PARSERCONTEXT *)pacParserContext),
				 palgi,
				 pcName,
				 pcInstance,
				 pcInit);
			}

			//t I could free pcName, pcInstance and pcInit here ?

			//- insert algorithm instance in the symbol table

			//t I prefer to move this code to the
			//t AlgorithmListPush non-terminal, but that
			//t does not work because
			//t ParserContextGetActual() sometimes returns
			//t NULL overthere, don't know why.

			SymbolAddChild
			    (ParserContextGetActual((PARSERCONTEXT *)pacParserContext), &palgs->hsle);

/* 			int iResult = ParserAddModel((PARSERCONTEXT *)pacParserContext, &palgs->hsle); */

/* 			if (!iResult) */
/* 			{ */
/* 			    NeurospacesError */
/* 				((PARSERCONTEXT *)pacParserContext, */
/* 				 "AlgorithmListPush", */
/* 				 "Error inserting algorithm instance (%s) in symbol table (class %s).", */
/* 				 $3, */
/* 				 $5); */
/* 			} */

			//- disable the algorithm

			ParserAlgorithmDisable
			    ((PARSERCONTEXT *)pacParserContext,
			     palgi,
			     pcName,
			     pcInstance,
			     pcInit);
		    }

		    //- sanity check : 
		    //- pvState should be PARSERSTATE_START_ALGORITHMS here

		    if (pvState != PARSERSTATE_START_ALGORITHMS)
		    {
			NeurospacesError
			    ((PARSERCONTEXT *)pacParserContext,
			     "AlgorithmListPop",
			     " Internal error :"
			     " non-terminal AlgorithmListPop encounters"
			     " messed up algorithm stack\n"
			     " Internal error : Expecting"
			     " PARSERSTATE_START_ALGORITHMS (== %i),"
			     " encountered %i\n\n",
			     PARSERSTATE_START_ALGORITHMS,

			     //t gives a warning on 64bit machines.

			     (int)pvState);

			//- dump core 
			//- (should contain interesting info to be examined)

			*(int *)NULL = 0xdeadbeaf;
		    }
		}
	;

/*
** shift & reduce identifier with index
**
** push state (if identifier, push as current element)
**
** push idin on current element stack
**
** optionally attach algorithms to the symbol via AlgorithmListPush non-terminal
*/ 

IdentifierOptionIndexPushedPidin	/* <pidin> */
	:
		IdentifierOptionIndex
		AlgorithmListPush
		{
#line
		    //- if an identifier is given

		    if ($1)
		    {
			//- set current working element name

			ParserCurrentElementPush
			    ((PARSERCONTEXT *)pacParserContext,
			     $1);
		    }

		    //- remember current context state

		    ParserContextPushState((void *)$1);
		}
	;

/*
** shift & reduce END
**
** pop state, if state pop pidin
**
** pop associated pidin from current element stack
*/

EndPushedPidin
	:
		TOKEN_END
		AlgorithmListPop
		{
#line
		    struct symtab_IdentifierIndex * pidin = NULL;

		    //- while algorithm on context stack

		    pidin
			= (struct symtab_IdentifierIndex *)
			  ParserContextPopState();

		    //- if identifier has been pushed

		    if (pidin)
		    {
			//- pop current working element name

			ParserCurrentElementPop
			    ((PARSERCONTEXT *)pacParserContext);
		    }
		}
	;

Identifier	/* <pcIdentifier> */
	:
		TOKEN_IDENTIFIER
		{
#line
		    //- get id name from lexical scanner

		    $$ = $1;
		}
	;

%%


